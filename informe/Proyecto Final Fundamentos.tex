\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{wrapfig}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\newgeometry{bottom=2.5cm, top=2.5cm, left=2.5cm, right=2.5cm}
\UseRawInputEncoding
\lstset{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

\begin{document}
\begin{center}
    “Año de la unidad, la paz y el desarrollo” 
\end{center}
\begin{center}
\LARGE
    UNIVERSIDAD NACIONAL DE INGENIERÍA 
\end{center}
\begin{center}
\LARGE
    FACULTAD DE CIENCIAS 
\end{center}
\begin{center}
\large
    Escuela profesional de Ciencias de la Computaci\'on
\end{center}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=.18]{unilogo.png}
\end{figure}
\begin{center}
\LARGE
PROYECTO FINAL
\end{center}
\begin{center}
\LARGE
\end{center}
\section*{Alumnos:}
\begin{itemize} 
    \item Sebastian Octavio Figueroa Rueda 20231447E
    \item Pinto Salas Danna Ninel 20234190E
    \item Yupanqui Quispe Roy Mauricio 20232148A
\end{itemize}
\section*{Profesor:}
\begin{itemize}
    \item Chulluncuy Reynoso Americo Andres
\end{itemize}
\section*{Secci\'on: CC112 - D}

\newpage
\tableofcontents
\newpage
\section{Introduccion}

Este proyecto tiene como finalidad proporcionar a los estudiantes una experiencia práctica en el uso de Python. Mediante esta iniciativa, se busca que los alumnos apliquen los conceptos previamente adquiridos en C++ en un entorno diferente, descubriendo las ventajas de Python en términos de simplicidad, eficiencia y aplicabilidad en múltiples áreas tecnológicas.

El proyecto también ofrecerá la oportunidad de trabajar con aplicaciones reales que emplean Python, incentivando así el interés de los estudiantes por áreas clave como la inteligencia artificial, el desarrollo web y la ciencia de datos. Además, se pretende que los participantes amplíen sus habilidades de programación y adquieran una visión más completa sobre la utilidad de distintos lenguajes de programación en situaciones prácticas.

En esencia, este proyecto aspira a reforzar los conocimientos previos de los estudiantes, a la vez que fomenta su curiosidad y desarrollo profesional en sectores tecnológicos emergentes y de gran relevancia.
\section{Fundamento Te\'orico}
\subsection{Filosofia y diseño}
    \subsubsection{El Zen de Python}
El Zen de Python es una colección de aforismos que capturan la filosofía del diseño de Python. Se puede acceder a ellos escribiendo import this en el intérprete de Python. Aquí algunos de los aforismos más destacados:
\begin{itemize}
    \item Bello es mejor que feo.
    \item Explícito es mejor que implícito.
    \item Simple es mejor que complejo.
    \item Complejo es mejor que complicado.
    \item Plano es mejor que anidado
    \item Espaciado es mejor que denso.
\end{itemize}
    \subsubsection{Diseño}    
    \begin{itemize}
    \item Legibilidad del código
    Uno de los objetivos principales de Python es que el código sea fácil de leer y entender. Esto se logra mediante una sintaxis limpia y el uso de sangrías para definir bloques de código en lugar de llaves o palabras clave.
    \item Simplicidad y consistencia
    Python sigue la regla de "una forma obvia de hacer las cosas". Esto promueve la   
    consistencia y facilita el aprendizaje y uso del lenguaje.
    \item Tipado dinámico pero fuerte
    Python es dinámicamente tipado, lo que significa que no se necesita declarar explícitamente los tipos de las variables, pero mantiene un tipado fuerte, evitando operaciones entre tipos incompatibles.
    \item Interpretado
    Python es un lenguaje interpretado, lo que significa que el código se ejecuta línea por línea, permitiendo una rápida iteración y prueba de código.
    \item Multiplataforma
    Python es compatible con múltiples plataformas, lo que permite ejecutar el mismo código en diferentes sistemas operativos sin necesidad de modificaciones significativas.
   \item Biblioteca estándar rica
    Python viene con una amplia biblioteca estándar que cubre muchas áreas, desde manejo de archivos hasta protocolos de Internet, facilitando el desarrollo sin necesidad de dependencias externas.\\
    
    \end{itemize}
    En conclusion la filosofía y el diseño de Python están orientados a crear un lenguaje que sea fácil de aprender y usar, promoviendo la escritura de código claro, legible y mantenible. Estos principios han contribuido significativamente a su popularidad y adopción en una amplia variedad de campos, desde desarrollo web hasta ciencia de datos y machine learning.
\subsection{Caracteristicas del lenguaje}
\begin{itemize}
    \item Tipado dinámico y fuerte
Python es un lenguaje de tipado dinámico, lo que significa que no es necesario declarar el tipo de una variable explícitamente; el tipo se determina automáticamente en tiempo de ejecución. Además, Python es fuertemente tipado, lo que implica que no permite la combinación implícita de tipos diferentes en una operación, evitando así errores ambiguos.

    \item Gestión automática de memoria
Python maneja la memoria automáticamente a través de un recolector de basura. Utiliza el conteo de referencias y un recolector de basura generacional para gestionar la memoria de forma eficiente.

    \item Sintaxis clara y concisa
Python utiliza una sintaxis clara y legible, con un fuerte énfasis en la legibilidad del código. Los bloques de código se definen por la indentación, no por llaves o palabras clave.

    \item Estructuras de datos incorporadas
Python incluye estructuras de datos de alto nivel que son fáciles de usar y muy poderosas.
    \begin{itemize}
        \item  Listas: Colecciones ordenadas y mutables.
    \item  Diccionarios: Colecciones desordenadas de pares clave-valor.
    \item Conjuntos: Colecciones desordenadas de elementos únicos.
    \item Tuplas: Colecciones ordenadas e inmutables.
    \item Programación Orientada a Objetos
   \item  Python soporta la programación orientada a objetos (POO), permitiendo la definición de clases y la creación de objetos.
    \end{itemize}
   

    \item Funciones de primera clase
Las funciones en Python son ciudadanos de primera clase, lo que significa que pueden ser pasadas como argumentos, retornadas desde otras funciones y asignadas a variables.

    \item Manejo de excepciones
Python tiene un sistema robusto para el manejo de excepciones, lo que permite gestionar errores de manera elegante y mantener el flujo del programa.

    \item Biblioteca estándar amplia
Python viene con una amplia biblioteca estándar que incluye módulos para tareas comunes como manejo de archivos, manipulación de cadenas, operaciones matemáticas, y mucho más.



    \item Multiplataforma
Python es compatible con múltiples plataformas (Windows, macOS, Linux), lo que permite escribir código que se puede ejecutar en diferentes sistemas operativos sin modificaciones significativas.

    \item Extensibilidad
Python se puede extender con módulos escritos en C o C++, lo que permite optimizar partes del código que necesitan mayor rendimiento.

    \item Interpretado
Python es un lenguaje interpretado, lo que significa que el código se ejecuta línea por línea, facilitando la depuración y la iteración rápida durante el desarrollo.

Apoyo a la programación funcional Python soporta paradigmas de programación funcional, incluyendo funciones lambda, map, filter y reduce.
\end{itemize}
En conclusión las características mencionadas hacen de Python un lenguaje poderoso y flexible, adecuado para una amplia gama de aplicaciones, desde scripts simples hasta complejos sistemas de inteligencia artificial. Su simplicidad, legibilidad y comunidad activa contribuyen a su continua popularidad y expansión en el mundo de la programación.
\subsection{Estructuras de Datos Incorporadas en Python}

Python incluye una variedad de estructuras de datos de alto nivel que facilitan el manejo y la manipulación de datos de manera eficiente y efectiva. A continuación se detallan las principales estructuras de datos incorporadas:
\begin{itemize}
    
\item Listas : Las listas son colecciones ordenadas y mutables que permiten almacenar una secuencia de elementos. Las listas pueden contener elementos de cualquier tipo y soportan operaciones como añadir, eliminar y modificar elementos.
Características:
\begin{itemize}
 \item Ordenadas: Mantienen el orden de inserción de los elementos.
 \item Mutables: Se pueden modificar después de su creación.
 \item Indexadas: Se puede acceder a los elementos mediante índices.
\end{itemize}
\item Diccionarios : Los diccionarios son colecciones desordenadas de pares clave-valor, donde cada clave es única y se utiliza para acceder a su valor correspondiente. Los diccionarios son útiles para almacenar datos asociados, como un mapa o un conjunto de propiedades.

Características:
\begin{itemize}
    \item Desordenados : No mantienen el orden de inserción (hasta Python 3.7, donde se garantizó el orden de inserción).
    \item Mutables: Se pueden modificar después de su creación.
    \item Claves Únicas: Cada clave en el diccionario debe ser única.
\end{itemize}
\item  Conjuntos : Los conjuntos son colecciones desordenadas de elementos únicos, lo que significa que no permiten elementos duplicados. Los conjuntos son útiles para operaciones matemáticas como la unión, intersección y diferencia.

\item Tuplas : Las tuplas son colecciones ordenadas e inmutables, lo que significa que no se pueden modificar después de su creación. Las tuplas son útiles para almacenar datos heterogéneos y pueden ser utilizadas como claves en los diccionarios debido a su inmutabilidad.

Características:
\begin{itemize}
    \item Ordenadas: Mantienen el orden de inserción de los elementos.
    \item Inmutables: No se pueden modificar después de su creación.
    \item Indexadas: Se puede acceder a los elementos mediante índices.
\end{itemize}
\end{itemize}
\subsection{Funciones y Manejo de Errores}
\subsubsection{Funciones}
Las funciones en Python son bloques de código reutilizables diseñados para realizar tareas específicas. Estas permiten modularizar el código, mejorar su legibilidad y facilitar su mantenimiento.
\begin{itemize}
 

   \item Definición de Funciones: Las funciones se definen utilizando la palabra clave def, seguida del nombre de la función y paréntesis. Dentro de los paréntesis se pueden incluir parámetros que la función recibirá como entrada.

   \item Llamada a Funciones: Una vez definida, una función puede ser llamada en cualquier parte del código pasando los argumentos necesarios.

   \item Parámetros y Argumentos: Las funciones pueden tener parámetros que permiten recibir información. Los argumentos son los valores que se pasan a la función cuando se llama.

   \item Valores por Defecto: Los parámetros pueden tener valores por defecto, permitiendo que la función se llame sin pasar todos los argumentos. Esto proporciona flexibilidad en la forma en que se pueden llamar las funciones.

   \item Funciones Lambda: Las funciones lambda son funciones anónimas definidas con la palabra clave lambda. Son útiles para operaciones pequeñas y rápidas que no requieren una función completa.

   \item Funciones de Primera Clase: En Python, las funciones son ciudadanos de primera clase, lo que significa que pueden ser asignadas a variables, pasadas como argumentos a otras funciones y retornadas desde otras funciones.
\end{itemize}
\subsubsection{Manejo de errores}
El manejo de errores en Python se realiza mediante un sistema robusto de excepciones, lo que permite gestionar errores de manera elegante y mantener el flujo del programa.
\begin{itemize}


    \item Bloques try-except: Los bloques try y except se utilizan para capturar y manejar excepciones. El código que puede generar una excepción se coloca dentro del bloque try, y el código para manejar la excepción se coloca dentro del bloque except.

    \item Bloque finally: El bloque finally se ejecuta siempre, independientemente de si se lanzó una excepción o no. Es útil para liberar recursos o realizar tareas de limpieza necesarias.

    \item Levantar Excepciones: Se puede utilizar la palabra clave raise para lanzar una excepción manualmente, lo que permite gestionar situaciones específicas de error.

    \item Excepciones Personalizadas: Python permite la creación de excepciones personalizadas definiendo nuevas clases que heredan de la clase base Exception. Esto es útil para manejar errores específicos de la aplicación de manera más precisa.
\end{itemize}
\subsection{Librerias y Herramientas}

Python se distingue no solo por su sintaxis simple y legible, sino también por su extensa colección de librerías y herramientas que facilitan el desarrollo en diversos dominios. A continuación, se describen algunas de las librerías y herramientas más relevantes en el ecosistema de Python.

\subsection{Biblioteca Estándar}
La biblioteca estándar de Python es una colección de módulos y paquetes que vienen incluidos con la instalación de Python. Estos módulos proporcionan soluciones para muchas tareas comunes, eliminando la necesidad de instalar librerías externas.
\begin{itemize}
\item os: Proporciona una forma de utilizar funcionalidades dependientes del sistema operativo, como manipulación de archivos y directorios.
\item sys: Permite acceder a variables y funciones específicas del intérprete de Python.
\item datetime: Ofrece clases para manipular fechas y horas de manera sencilla.
\item json: Permite trabajar con datos en formato JSON (JavaScript Object Notation).
\item math: Proporciona acceso a funciones matemáticas como trigonometría, logaritmos, y más.
\item urllib: Facilita el trabajo con URL, incluyendo la recuperación de datos desde la web.
\end{itemize}
\subsection{Librerías de Terceros}
Además de la biblioteca estándar, Python cuenta con una amplia gama de librerías de terceros que extienden su funcionalidad. Algunas de las más populares incluyen:
\begin{itemize}


    \item NumPy: Proporciona soporte para grandes matrices y matrices multidimensionales, junto con una colección de funciones matemáticas de alto nivel para operar con estos arreglos.
    \item pandas: Ofrece estructuras de datos y herramientas de análisis de datos de alto rendimiento, especialmente útiles para la manipulación de datos tabulares.
    \item matplotlib: Permite crear visualizaciones estáticas, animadas e interactivas en Python.
requests: Simplifica el envío de solicitudes HTTP, siendo mucho más intuitivo que los módulos de la biblioteca estándar.
    \item scikit-learn: Proporciona herramientas simples y eficientes para análisis de datos y minería de datos, incluyendo algoritmos de aprendizaje automático.
    \item Flask: Un micro framework para desarrollo web, que permite crear aplicaciones web de manera sencilla y rápida.
    \item Django: Un framework de alto nivel para el desarrollo web, que fomenta el desarrollo rápido y el diseño limpio y pragmático.
\end{itemize}
\newpage
\section{Desarrollo}
\subsection{Parte I}

\subsubsection{Ejercicio 1}
\begin{lstlisting}
def factorial(n):
    # Caso base: factorial de 0 o 1 es 1
    if n == 0 or n == 1:
        return 1
    # Caso recursivo: n * factorial(n-1)
    else:
        return n * factorial(n - 1)

# Solicitar al usuario que ingrese un número entero
while True:
    try:
        numero = int(input("Ingresa un número entero para calcular su factorial: "))
        if numero < 0:
            print("El factorial no está definido para números negativos.")
        else:
            resultado = factorial(numero)
            print(f"El factorial de {numero} es: {resultado}")
            break
    except ValueError:
        print("Por favor, ingresa un número entero válido.")  

\end{lstlisting}



\subsubsection{Ejercicio 3}
\begin{lstlisting}
def invertir_cadena(cadena):
    # Usamos rebanadas de cadena para invertir la cadena
    cadena_invertida = cadena[::-1]
    return cadena_invertida

# Solicitar al usuario que ingrese la cadena
cadena_original = input("Ingrese una cadena para invertirla: ")

# Llamar a la funcipn para invertir la cadena ingresada por el usuario
cadena_invertida = invertir_cadena(cadena_original)

# Mostrar resultados
print(f"Cadena original: {cadena_original}")
print(f"Cadena invertida: {cadena_invertida}")

\end{lstlisting}

\subsubsection{Ejercicio 5}
\begin{lstlisting}
# Crear una lista inicial
lista = [1, 2, 3, 4, 5]

# Mostrar la lista original
print("Lista original:", lista)

# Modificar un elemento especifico
lista[2] = 10

# Mostrar la lista despues de la modificacion
print("Lista modificada:", lista)

# Añadir un nuevo elemento
lista.append(6)

# Mostrar la lista después de añadir un elemento
print("Lista después de añadir:", lista)

# Eliminar un elemento
del lista[1]

# Mostrar la lista después de eliminar un elemento
print("Lista después de eliminar:", lista)

\end{lstlisting}
\newpage
\subsubsection{Ejercicio 7}
\begin{lstlisting}
agenda_telefonica = {}

# Funcion para agregar un contacto a la agenda
def agregar_contacto(nombre, telefono): 
    agenda_telefonica[nombre] = telefono 
    print(f"Contacto '{nombre}' agregado correctamente con el número '{telefono}'.")

# Funcion para buscar un contacto en la agenda
def buscar_contacto(nombre):
    if nombre in agenda_telefonica:
        print(f"Nombre: {nombre} - Teléfono: {agenda_telefonica[nombre]}")
    else:
        print(f"El contacto '{nombre}' no se encuentra en la agenda.")

# Funcion para mostrar todos los contactos en la agenda
def mostrar_contactos():
    if agenda_telefonica:
        print("Lista de contactos en la agenda:")
        for nombre, telefono in agenda_telefonica.items():
            print(f"Nombre: {nombre} - Teléfono: {telefono}")
    else:
        print("La agenda está vacía.")

# Ejemplo de uso de la agenda telef\'onica
agregar_contacto("Juan", "123456789")
agregar_contacto("María", "987654321")
agregar_contacto("Pedro", "555123456")

# Mostrar todos los contactos
mostrar_contactos()

# Buscar un contacto
buscar_contacto("Maria")
buscar_contacto("Carlos")  # Ejemplo de contacto que no existe en la agenda

\end{lstlisting}
\subsubsection{Ejercicio 11}
\begin{lstlisting}
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad
        
    def mostrar_datos(self):
        print(f'Nombre: {self.nombre}, Edad: {self.edad}')

# Ejemplo de uso de la clase Persona
if __name__ == "__main__":
    # Crear una instancia de Persona
    persona1 = Persona("Fabrizzio", 22)
    
    # Mostrar los datos de la persona1
    persona1.mostrar_datos()

\end{lstlisting}
\newpage
\subsection{Parte II}
\subsubsection{Ejercicio 1}
\begin{lstlisting}
# Funcion para realizar la operación de suma
def suma(a, b):
    return a + b

# Funcion para realizar la operación de resta
def resta(a, b):
    return a - b

# Funcion para realizar la operación de multiplicación
def multiplicacion(a, b):
    return a * b

# Funcion para realizar la operación de división
def division(a, b):
    # Manejo de división entre cero
    if b == 0:
        return "Error: división entre cero"
    else:
        return a / b

# Funcion principal que ejecuta la calculadora
def calculadora():
    while True:
        print("\nCalculadora básica")
        print("Seleccione la operación:")
        print("1. Suma")
        print("2. Resta")
        print("3. Multiplicación")
        print("4. División")
        print("5. Salir")

        opcion = input("Ingrese la opción (1/2/3/4/5): ")

        if opcion == '5':
            print("¡Hasta luego!")
            break
        
        if opcion in ('1', '2', '3', '4'):
            num1 = float(input("Ingrese el primer número: "))
            num2 = float(input("Ingrese el segundo número: "))

            if opcion == '1':
                print(f"{num1} + {num2} = {suma(num1, num2)}")
            elif opcion == '2':
                print(f"{num1} - {num2} = {resta(num1, num2)}")
            elif opcion == '3':
                print(f"{num1} * {num2} = {multiplicacion(num1, num2)}")
            elif opcion == '4':
                print(f"{num1} / {num2} = {division(num1, num2)}")
        else:
            print("Opcion inválida. Por favor, ingrese una opcion válida (1/2/3/4/5).")

# Llamada a la función principal de la calculadora
calculadora()

\end{lstlisting}
\newpage
\subsubsection{Ejercicio 2}
\begin{lstlisting}
import random

def jugar_adivina_numero():
    print("¡Bienvenido al juego de adivinar el número!")
    print("Estoy pensando en un número entre 1 y 10")
    numero_secreto = random.randint(1, 10)
    intentos_realizados = 0
    
    while True:
        intento = int(input("Intenta adivinar el número: "))
        intentos_realizados += 1
        
        if intento < numero_secreto:
            print("El número secreto es mayor. Intenta de nuevo.")
        elif intento > numero_secreto:
            print("El número secreto es menor. Intenta de nuevo.")
        else:
            print(f"Felicitaciones! ¡Adivinaste el número secreto {numero_secreto} en {intentos_realizados} intentos!")
            break

    volver_a_jugar = input("¿Quieres jugar de nuevo? (s/n): ").lower()
    if volver_a_jugar == 's':
        jugar_adivina_numero()
    else:
        print("Gracias por jugar. ¡Hasta luego!")

# Iniciar el juego
jugar_adivina_numero()
\end{lstlisting}
\subsubsection{Ejercicio 3}
\begin{lstlisting}
# Definimos las tasas de cambio con respecto al PEN (SOl PERUANO)
#Diccionario
cambio_dicc = {
    'PEN': 1.0,    # Sol peruano
    'EUR': 0.24,   # Euro
    'CAD': 0.36,  # Yen Japonés
    'GBP': 0.20,   # Libra Esterlina
    'MXN': 4.77    # Peso Mexicano
}

def conversor(cantidad, moneda_origen, moneda_destino):
    """Convierte una cantidad de una moneda a otra usando las tasas de cambio predefinidas."""
    if moneda_origen not in cambio_dicc or moneda_destino not in cambio_dicc:
        raise ValueError("Moneda no soportada.")
    
    # Convertir la cantidad a PEN primero
    cantidad_pen = cantidad / cambio_dicc[moneda_origen]
    
    # Convertir de PEN a la moneda destino
    conversion_cantidad = cantidad_pen * cambio_dicc[moneda_destino]
    
    return conversion_cantidad

def main():
    print("Conversor de Monedas")
    print("Monedas soportadas: PEN, EUR, JPY, GBP, MXN")
    
    moneda_origen = input("Introduce la moneda de origen: ").upper()
    moneda_destino = input("Introduce la moneda de destino: ").upper()
#aqui verificamos que el monto sea un numero    
    while True:
        cantidad_input = input("Introduce la cantidad a convertir: ")
        try:
            cantidad = float(cantidad_input)
            break
        except ValueError:
            print("Error: La cantidad debe ser un número valido.")
#
    try:
        resultado = conversor(cantidad, moneda_origen, moneda_destino)
        print(f"{cantidad} {moneda_origen} son {resultado:.2f} {moneda_destino}.")
    except ValueError as e:
        print(e)

#Esta ultima linea  asegura que la funcion main() 
# se ejecute solo cuando el script se ejecuta directamente.
if __name__ == "__main__":
    main()

\end{lstlisting}

\subsubsection{Ejercicio 4}
\begin{lstlisting}
class Tarea:
    def __init__(self, descripcion):
    
        #Inicializa una nueva tarea con la descripcion proporcionada y la marca como no completada.
        
        self.descripcion = descripcion
        self.completada = False

    def marcar_completada(self):
        
        #Marca la tarea como completada.
        
        self.completada = True

    def __str__(self):
        
        #Devuelve una representación en cadena de la tarea, indicando si esta completada o no.
        
        estado = "Hecha" if self.completada else "Pendiente"
        return f"{self.descripcion} - {estado}"


class GestorTareas:
    def __init__(self):
        
        #Inicializa el gestor de tareas con una lista vacia de tareas.
        
        self.tareas = []

    def agregar_tarea(self, descripcion):
        
        #Agrega una nueva tarea con la descripcion proporcionada a la lista de tareas.
        #Devuelve un mensaje de confirmacion.
    
        tarea = Tarea(descripcion)
        self.tareas.append(tarea)
        return f"Tarea agregada con éxito: {descripcion}"

    def eliminar_tarea(self, indice):
        
        #Elimina la tarea en el indice proporcionado de la lista de tareas.
        #Devuelve un mensaje de confirmacion si la operacion es exitosa,
        #o un mensaje de error si el indice es invalido.
        
        if 0 <= indice < len(self.tareas):
            tarea_eliminada = self.tareas.pop(indice)
            return f"Tarea eliminada con éxito: {tarea_eliminada.descripcion}"
        else:
            return "Índice de tarea inválido"

    def marcar_tarea_completada(self, indice):
        
        #Marca la tarea en el indice proporcionado como completada.
        #Devuelve un mensaje de confirmacion si la operación es exitosa,
        #o un mensaje de error si el índice es invalido.
        
        if 0 <= indice < len(self.tareas):
            self.tareas[indice].marcar_completada()
            return f"Tarea marcada como completada: {self.tareas[indice].descripcion}"
        else:
            return "Índice de tarea inválido"

    def listar_tareas(self):
        
        #Devuelve una lista en cadena de todas las tareas y sus estados.
        #Si no hay tareas, devuelve un mensaje indicando que no hay tareas disponibles.
        
        if not self.tareas:
            return "No hay tareas disponibles"
        return "\n".join([f"{idx}. {tarea}" for idx, tarea in enumerate(self.tareas)])


def main():
    
    #Función principal que maneja la interacción del usuario con el gestor de tareas.
    #Muestra un menu y permite agregar, eliminar, marcar como completadas y listar tareas.
    
    gestor = GestorTareas()
    while True:
        # Muestra el menu de opciones
        print("\nOpciones:")
        print("1. Agregar tarea")
        print("2. Eliminar tarea")
        print("3. Marcar tarea como completada")
        print("4. Listar tareas")
        print("5. Salir")
        opcion = input("Elige una opción: ")

        if opcion == '1':
            # Agregar una nueva tarea
            descripcion = input("Descripcion de la tarea: ")
            mensaje = gestor.agregar_tarea(descripcion)
            print(mensaje)
        elif opcion == '2':
            # Eliminar una tarea existente
            indice = int(input("Índice de la tarea a eliminar: "))
            mensaje = gestor.eliminar_tarea(indice)
            print(mensaje)
        elif opcion == '3':
            # Marcar una tarea como completada
            indice = int(input("Indice de la tarea a marcar como completada: "))
            mensaje = gestor.marcar_tarea_completada(indice)
            print(mensaje)
        elif opcion == '4':
            # Listar todas las tareas
            mensaje = gestor.listar_tareas()
            print(mensaje)
        elif opcion == '5':
            # Salir del programa
            break
        else:
            # Manejo de opcion invalida
            print("Opcion invalida")

if __name__ == "__main__":
    main()

\end{lstlisting}
\newpage
\subsection{Parte III}
\begin{lstlisting}
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# Crear un conjunto de datos simple
data = {
    'tenure': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'monthlycharges': [20, 30, 40, 50, 60, 70, 80, 90, 100, 110],
    'churn': [0, 0, 0, 1, 0, 1, 1, 0, 1, 1]
}

df = pd.DataFrame(data)

# Dividir el conjunto de datos en entrenamiento y prueba
X = df[['tenure', 'monthlycharges']]
y = df['churn']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Entrenar el modelo de regresión logística
model = LogisticRegression()
model.fit(X_train, y_train)

# Hacer predicciones
y_pred = model.predict(X_test)

# Evaluar el modelo
accuracy = accuracy_score(y_test, y_pred)
print('Accuracy:', accuracy)

# Mostrar las probabilidades predichas
print('Probabilidades predichas:', model.predict_proba(X_test))

\end{lstlisting}
\section{Conclusiones}
Python se ha consolidado como uno de los lenguajes de programación más versátiles y populares en la actualidad. Su diseño enfocado en la simplicidad y la legibilidad lo hace accesible tanto para principiantes como para programadores experimentados. Las características clave de Python, como el tipado dinámico, la gestión automática de memoria y las estructuras de datos incorporadas, contribuyen a su facilidad de uso y eficiencia.

La extensa biblioteca estándar de Python y su ecosistema de librerías de terceros permiten a los desarrolladores abordar una amplia gama de aplicaciones, desde desarrollo web y automatización de tareas hasta análisis de datos y aprendizaje automático. Además, las herramientas y entornos de desarrollo compatibles con Python facilitan la escritura, depuración y mantenimiento del código.

El manejo robusto de excepciones y la flexibilidad en la definición de funciones permiten a los desarrolladores escribir código robusto y reutilizable. La capacidad de Python para integrarse con otros lenguajes y sistemas, junto con su soporte multiplataforma, asegura su relevancia en diversos entornos y aplicaciones.

La comunidad activa y vibrante de Python, junto con su enfoque en la colaboración y el código abierto, ha impulsado el desarrollo continuo y la mejora del lenguaje. Esto se refleja en la cantidad de recursos educativos, proyectos open source y eventos comunitarios disponibles para los desarrolladores de Python.

En resumen, Python no solo es un lenguaje poderoso y flexible, sino también una herramienta esencial en el arsenal de cualquier desarrollador moderno. Su combinación de simplicidad, versatilidad y una comunidad de apoyo lo convierte en una elección ideal para una amplia gama de proyectos y desafíos tecnológicos.


\end{document}